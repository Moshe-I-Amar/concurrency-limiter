/**
 * @fileoverview Type contracts for the concurrency-limiter system.
 * Defines all shared interfaces and type aliases used across the library.
 * Generated by Agent 1
 * Date: 2026-02-18
 */

// ─── Core Task Type ──────────────────────────────────────────────────────────

/**
 * A zero-argument async function representing a single unit of work.
 * This is the universal input type accepted by the concurrency limiter.
 *
 * @template T The resolved value type of the task's promise.
 *
 * @example
 * const fetchUser: AsyncTask<User> = () => fetch('/api/user').then(r => r.json());
 */
export type AsyncTask<T> = () => Promise<T>;

/**
 * A function that accepts a task and returns a Promise for its result,
 * potentially subject to scheduling, queueing, or rate-limiting.
 *
 * @template T The resolved value type of the task.
 *
 * @example
 * const run: TaskRunner<string> = (task) => limiter.enqueue(task);
 */
export type TaskRunner<T> = (task: AsyncTask<T>) => Promise<T>;

// ─── Queue Internals ─────────────────────────────────────────────────────────

/**
 * @internal
 * Represents one item waiting in or actively running from the queue.
 * This type is intentionally not exported; it is an implementation detail
 * of the limiter's internal scheduling mechanism.
 *
 * @template T The resolved value type of the queued task's promise.
 */
interface QueueItem<T> {
  /** The unit of work to be executed when a concurrency slot becomes available. */
  task: AsyncTask<T>;
  /** Called with the task's resolved value upon successful completion. */
  resolve: (value: T) => void;
  /** Called with the rejection reason if the task throws or rejects. */
  reject: (reason: unknown) => void;
}

// ─── Configuration ───────────────────────────────────────────────────────────

/**
 * Options passed to the ConcurrencyLimiter constructor.
 * Controls the maximum degree of parallelism enforced by the limiter.
 *
 * @example
 * const options: ConcurrencyLimiterOptions = { maxConcurrent: 5 };
 */
export interface ConcurrencyLimiterOptions {
  /**
   * The maximum number of tasks that may execute concurrently.
   * Must be a positive integer greater than or equal to 1.
   * Values less than 1 or non-integer values are considered invalid
   * and should be rejected by the implementing constructor.
   *
   * @minimum 1
   */
  maxConcurrent: number;
}

// ─── Observability ───────────────────────────────────────────────────────────

/**
 * A read-only snapshot of the limiter's runtime state at a point in time.
 * All fields are readonly to prevent accidental mutation of observed values.
 *
 * @example
 * const stats: LimiterStats = limiter.getStats();
 * console.log(`Active: ${stats.activeCount}, Queued: ${stats.queueLength}`);
 */
export interface LimiterStats {
  /** The configured maximum number of concurrent tasks for this limiter instance. */
  readonly maxConcurrent: number;
  /** The number of tasks currently executing (slots in use). */
  readonly activeCount: number;
  /** The number of tasks waiting in the queue for an available slot. */
  readonly queueLength: number;
}

// ─── HTTP Layer ──────────────────────────────────────────────────────────────

/**
 * Options for constructing the HTTP request wrapper that applies
 * concurrency limiting to outbound fetch calls.
 *
 * @example
 * const httpOptions: HttpRequestOptions = {
 *   maxConcurrentRequests: 10,
 *   defaultInit: { headers: { 'Authorization': 'Bearer token' } },
 * };
 */
export interface HttpRequestOptions {
  /**
   * The maximum number of HTTP requests that may be in-flight simultaneously.
   * Passed directly to the underlying ConcurrencyLimiter as `maxConcurrent`.
   */
  maxConcurrentRequests: number;
  /**
   * Optional default fetch `RequestInit` options applied to every request.
   * Per-request init options are merged on top of these defaults, with
   * per-request values taking precedence over defaults on key conflicts.
   */
  defaultInit?: RequestInit;
}
